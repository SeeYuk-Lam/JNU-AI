# 深入C语言的类型
整数
• char、short、int、long、long long
浮点数
• float、double、long double
逻辑
• bool
指针
 自定义类型
# sizeof
sizeof是**静态运算符**，他的结果在编译时刻就决定了
不要在sizeof的括号里做运算，这些运算不会做的，他不是函数！！！！！

# 1.整数integer
char：1字节：-128 ~ 127
short：2字节：-32768 ~ 32767
int：取决于编译器（CPU），通常的意义是“1个字” 通常4个字节 
long：取决于编译器（CPU），通常的意义是“1个字”
long long：8字节
A character variable canst a time store 1 character
## 1.1unsigned

char 可表示-128~+127
Unsigned char 可表示0~255(把负数部分全搞到正数)
不看成补码，看成纯二进制
## 1.2 整数的输入输出
只有两种形式，int和long long
%d：int
%u：unsigned
%ld：long long
%lu：unsigned long long
## 1.3 8进制和16进制
一个以0开始的数字字面量是8进制 
	%o用于8进制
一个以0x开始的数字字面量是16进制
	%x用于16进制
8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关
也就是只有输出的不同
## 1.4 选择整数类型
1. 为什么整数要有那么多种？
	为了准确表达内存，做底层程序的需要
2. 没有特殊需要就选int
3. unsigned与否只是**输出的不同**，内部计算是一样的
## 1.5 字符
char是一种整数，也是一种特殊的类型：字符。
用单引号表示的字符字面量：'a', '1'
只能用单引号括起来，不能用双引号，并且单引号里面只能有一个字符
printf和scanf里用%c来输入输出字符
### 1.5.1 大写字母和小写字母转换（重要！！）
明确！小写字母比大写字母大！32
’大写字母‘ + ‘a’ - ‘A’ 可以把一个大写字母变成小写字母
’小写字母‘ + ‘A’ - ‘a’ 可以把一个小写字母变成大写字母
### 1.5.2 字符的输入输出
如何输入'1'这个字符给char c？
scanf("%c", &c); 输入：1
scanf("%d", &i); c=i;  输入：49
'1'的ASCII编码是49，所以当`c==49时，它代表'1'`
### 1.5.3 逃逸字符
都只占一个字节。
```
\n  换行
\t 到下一个表格位
\" 双引号
\' 单引号
```



# 2.浮点数mantissa
## 2.1 表示范围
![[Pasted image 20240612204423.png]]
字节数要记住
有效数字是指小数点后6位和小数点后15位
## 2.2浮点的输入输出

^39c3e8

![[Pasted image 20240612204545.png]]
%e：以科学计数法表示浮点数
float和double输入不同，一个是%f一个是%lf，但printf是一样都是%f ^255546
printf中，%f通杀单精度和双精度 
在scanf中，%f和%lf才有区
## 2.3 科学计数法
![[Pasted image 20240612204836.png]]
$-5.67\times10^{16}$
## 2.4 输出精度
`printf("%5.3f",0.0049)`
5表示整个数字的宽度，包括小数点和符号，总共占用5个字符位置
3表示保留3位小数
## 2.5 浮点运算的精度
### 2.5.1 float和double
带小数点的字面量默认是double而非float！！！！！
float需要用f或F后缀来表明身份
### 2.5.2 如何判断两个浮点数相等？（重点！！！！！）
```c
f1 = f2; //完全错误！

fabs(f1-f2)<1e-12;//两个浮点数相减为一个很小的数，表四这两个浮点数相等
```
`fabs` 是C语言标准库中的一个函数，定义在 `math.h` 头文件中，用于计算浮点数的绝对值。

# 3.类型转换
## 3.1 自动类型转换

^edf8d8

当一个运算符两边数据相同，是不会进行自动类型转换的
1. +、-、 * 、/运算的两个数中有一个数为float或double型，结果是double型
2. 如果int型与float或double型数据进行运算，先把int型和float型数据转换为double型，然后进行运算，结果是double型。
3. 字符(char)型数据与整型数据进行运算，就是把**字符的ASCII代码与整型数据进行运算**。如果字符型数据与实型数据进行运算，则将字符的ASCII代码转换为double型数据，然后进行运算
## 3.2 I/O时的自动类型转换
对于printf，任何小于int的类型会被转换成int；float会被转换成double
char、short→int 
long、long long→long long
但是scanf不会，要输入short，需要%hd
## 3.3 强制类型转换
只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值
还是类型都不改变
## 3.4 数据的存储类型（重要）
![[Pasted image 20240612212001.png]]
（1） 自动存储automatic storage类
存储在**内存memory**，初始化的值**不可预测（垃圾值）**，作用范围是局部到定义变量的块，生命周期是定义变量的块内。
例：auto int i,j;

（2） 寄存器register存储类
存储在CPU，初始化值默认为0，余下同上。
例：register int i;

（3） 静态static存储类
存储在内存，初始化值为0，作用范围是局部到定义变量的块
**生命周期：变量的值在不同的函数调用之间持续存在。**
![[Pasted image 20240627201131.png]]

如果是auto的i，每次进入increment 函数，i都会被刷新成1，而且函数结束后局部变量i便被释放，而static的i的生命周期和main函数周期一样连续，不会被刷新，每次调用increment的i值可以留存。

（4） 外部external存储类
**也就是定义在函数外的变量**
存储在内存，初始化值为0，作用范围是全局global，和程序同生共死（程序不结束，它就不被释放）。

![](file:///C:\Users\地狱拖~1\AppData\Local\Temp\ksohtml37832\wps2.jpg) 

关于蓝色框框：这里第一个语句是声明，而第二个语句是定义。当我们声明一个变量时，没有为它保留空间，而当我们定义它时，内存中为它保留了空间。我们必须声明y，因为它在printf()中使用，在遇到它的定义之前。没有必要声明x，因为它的定义是在使用之前完成的。还要记住，**一个变量可以声明几次，但只能定义一次。**

例子2：

![](file:///C:\Users\地狱拖~1\AppData\Local\Temp\ksohtml37832\wps3.jpg) 

先输出main中定义的x（20），再输出全局定义的x（10），理解变量的作用范围。

Static：希望变量的值在不同的函数调用之间保持不变。
在程序的整个运行期间都存在，但只在定义它的文件内可见，对其他文件不可见
Register：那些在程序中经常使用的变量。（寄存器可以加快读取调用速度）,不影响作用域
Extern：几乎所有的函数都在使用的那些变量。将所有变量声明为外部变量会造成大量内存空间的浪费，因为这些变量在程序的整个生命周期中都将保持活动状态。所以文件都可以使用
Auto：没有上述需求，用auto。局部变量