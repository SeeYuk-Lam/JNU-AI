# 1.取地址运算&
&i：获取变量i的地址，操作数必须是**变量**
&不能对没有地址的东西取地址

# 2.指针
**指针就是地址**
**指针变量就是保存地址的变量**

### 2.1指针变量
`int*p =&i`
`int*`代表的是**指针变量的基类型**
`p`代表的是**指针变量的名称**

小思考：写成`int p=&i`会不会报错？
<font color=red>不会，因为i的地址本身就是一个整形的数，它会被储存在整形变量p中。这样虽然不会报错，但没有意义，后面无法用*p来表示i</font>

普通变量的值是**实际的值**
指针变量的值是**具有实际值的变量的地址**
### 2.2 基类型
指向什么，什么就是基类型
```C
float i = 3.14;
float *p  = i;
```


### 2.3运算符
`*`是一个单目运算符，用来访问指针的值所表示的地址上的变量，简记为“指向”运算符
表示把指针上的变量取出来
`*p`**完全等同于变量i**
解释：
如果一个指针变量指向某个普通变量，并且p存放了普通变量i的地址
则**p完全指向了普通变量i**
`*p`就完全等同于i
或者说：`*p`可以完全用i来代替，两者地址相同，值相同，一模一样。

### 2.4 指针的运算符&和*
![[Pasted image 20240424214209.png]]
### 2.5 指针应用场景
#### 2.5.1 在函数中交换两个变量的值
```C
void swap(int *pa,int *pb)在函数被调用的时候得到了a和b的地址
{
int i = *pa;在函数内部可以通过这个指针访问外面的a和b
*pa = *pb;
*pb = i;
}

int main()
{
int a = 1;
int b =2;
swap(&a,&b);
printf("%d,%d",a,b);
return 0;
}
```

#### 2.5.2 让函数返回多个值
正常函数return只能返回一个值
如果要让函数一次性返回多个值，则必须要用指针
（在函数里面修改等同于直接修改外部的值）

### 2.6 使用指针常见的错误（没有初始化）
**定义了指针变量，还没有指向任何变量，就开始使用指针**
如果一个指针变量没有初始化，内部储存的是垃圾值的地址（未知的地址），
我们没有权限去直接调用这个地址（无法使用*p的指令），没有控制权
不能把`*p`当成普通变量去使用，不可改变里面地址指示的值
```C
int * q；
i = 5;
*q = i;//error,错误，不可改变未赋值的指针变量的地址指示的值
```
```C
int*q；
i = 5；
q = &i；
*q = 10；//正确，指针变量已经有赋值，可以改变*q  
```
**因此每次在使用`*q`时，要时刻注意有没有给指针变量p赋一个地址**

# 3.指针与数组
（指针就是地址，指针指向什么基类型就是什么→可用于p+1的分析）
## 3.1 函数与数组
### 3.1.1 传入函数的数组是什么？
**函数参数中的数组`a[]`其实是指针,相当于`*a`**
* 我们在主函数可以用`sizeof(a)/sizeof(a[0])`来计算数组个数
* 但是因为在函数中，传入的数组本质为指针，`sizeof(a)==sizeof(int*)`指针长度/整体长度，无法计算出数组长度
### 3.1.2 数组参数
以下四种函数原型是等价的
**int 函数（指针变量，整型变量）**
* ·`int sum(int*ar,int n)
* `int sum(int*,int)`
* `int sum(int ar[],int n)`
* `int sum(int [],int)`

## 3.2 指针与数组核心
## 3.2.1 数组变量是特殊的指针（数组名=指针）
* 数组名本身表达地址，无需用&取地址即可赋给指针变量
`int a[10]; int*p=a;`
* 数组的元素是整型变量，需要用&取地址
`int *p = a[0];int *(p+1) = a[1];`
* `*`运算符可以对指针做，也可以对数组做
`*a = a[0]`

## 3.2.2 数组指针和指针数组

^01799a

1. `int *p` **整型指针**
* 代表一个一维数组的函数名 a
* 指向a[0]一个元素
2.  `int (*p)[3]` **数组指针**
* 定义指向二维数组某一行的指针
* **指向**一个包含**三个元素**的一维数组a[0]
4. `int *p [3]` **指针数组**
* 代表一个储存三个地址/指针`*p`的指针数组
* 后面可以用来做字符串数组

## 3.2.3 二维数组与数组指针
1. 一维
```c
int *p;
int a[3];
p = a;// 把a[0]的地址赋给指针变量p，或者说p就是a，p[0]==a[0]
```

| 表达式      | 含义     |
| -------- | ------ |
| p/a      | 指向a[0] |
| p+1      | 指向a[1] |
| `*p`     | a[0]的值 |
| `*(p+1)` | a[1]的值 |
 
2.二维
```c
int (*p)[3];//指向一个包含三个元素的一维数组，对应到二维数组就是固定有三列
int a[4][3];//四行三列的二维数组
p = a；
```

| 表达式            | 含义                       |
| -------------- | ------------------------ |
| p/a            | `&a[0]`指向a[0]（指向二维数组第0行） |
| p+1            | `&a[1]`指向a[1]（指向二维数组第1行） |
| `*p`           | `&a[0][0]`指向`a[0][0]`    |
| `*p+1`(基类型是*p) | `&a[0][1]`指向`a[0][1]`    |
| p[i]+j         | `&a[i][j]`指向`a[i][j]`    |
| `**p`          | `a[0][0]`                |
二维数组的层次
![[Pasted image 20240629125404.png]]
# 4.指针与const
指针(地址)→可以是const
值（地址所指向的值）→可以是const
## 4.1 常量指针
`int *const p = &i;`
这意味着`ptr`指针（ptr）不能被修改，即它始终指向同一个`int`类型的变量，但通过`ptr`所指向的值（`*ptr`）是可以修改的。
**地址不能被修改,地址所指向的值可以修改**
**例子**
```C
#include <stdio.h>

int main() {
    int value = 10;
    int *const ptr = &value; // 定义一个常量指针

    *ptr = 20; // 正确：通过指针修改值
    printf("Value: %d\n", *ptr);

    // ptr = &anotherValue; // 错误：不能改变指针指向的地址

    return 0;
}
```

## 4.2 指向常量的指针
`const int *ptr = &i`
这里`ptr`是一个指向`int`类型常量的指针。这意味着通过`ptr`指针所指向的值不能被修改，但`ptr`指针（即地址）可以改变。
**地址可以修改，地址所指向的值不可以修改**
**例子**
```c
#include <stdio.h>

int main() {
    int value = 10; // 定义一个值
    const int *ptr = &value; // 定义一个指向常量的指针

    // *ptr = 20; // 错误：尝试修改常量
    printf("Value: %d\n", *ptr); // 正确：通过指针读取值

    // ptr = &anotherValue; // 正确：可以改变指针指向的地址
    // 但value的值不能通过ptr改变

    value = 20；//正确，是*ptr为常量，value本质还是变量
    return 0;
}
```
#### 指向常量的指针的应用
我们在主函数可以任意修改的变量，如果通过指向常量的指针的方式传入其他函数，在其他函数中，只能通过指针去访问这个值，无法通过指针去改变这个值（避免主函数变量遭到修改）

`const int* p = &i;`指向常量的指针
`int const* p= &i`指向常量的指针
`int *const p=&i`常量指针

# 5.const数组
`const int a[]={1,2,3,4,5,6}`
* 数组名a已经是指针常量了
* 这里的const表示数组的每个单元都是const int
* 所以必须通过初始化进行赋值，无法通过a[0]=1这种方式赋值
#### 保护数组值
因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值，为了保护数组，可以采用const数组的方式
`int sum(const int a[],int length);`传入函数

# 6.指针是可计算的
给指针加1代表让指针指向下一个变量
```c
int a[10];
int *p = a;
p // 指向a[0]
p+1 // 指向a[1]
*(p+1) // 等于a[1]
```

## `*p++`是什么意思？？？
p++是表达式，表示的是先p，后p+1
故`*p++`先表示a[0]再表示a[1]
即为取出p所指的那个数据来，完事之后顺便把p移到 下一个位置去

**考点**
p++和++p的区别
`p++` 会在表达式求值后递增（先p后＋1），
而 `++p` 会在表达式求值前递增（先+1，后++1）

# 7.指针的类型
* 无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
* 但是指向不同类型的指针是不能直接互相赋值的，这是为了避免用错指针
## 7.1 指针的类型转换
* void* 表示不知道指向什么东西的指针
* 指针也可以转换类型
* `int *p=&i;void*q=(void*)p`
* 这并没有改变p所指的变量的类型，而是让后人用不 同的眼光通过p看它所指的变量

# 8.动态内存分配
**为什么要引入动态内存分配？**
因为在c99之前，数组的[ ]中不能引入变量，那么怎么实现这个功能呢？
→动态内存分配
`int *a = (int*)malloc(n*sizeof(int))`
其中a就是一个数组，可以直接用，对他进行赋值
## 8.1 malloc
* 头文件：#include <stdio.h>
* 函数原型：`void *malloc(size_t size);`
	 void*:函数返回一个通用指针，可以转化为任何类型的指针
	 size_t size:需要分配的字节数
* 如何用在动态数组上：`(int*)malloc(n*sizeof(int))`
## 8.2 free()
使用动态数组`int *a = (int*)malloc(n*sizeof(int))`后
记得使用`free(a)`来释放分配的内存

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *dynamicArray;
    int n;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    // 动态分配一个整数数组
    dynamicArray = (int *)malloc(n * sizeof(int));

    if (dynamicArray == NULL) {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(EXIT_FAILURE);
    }

    // 使用动态分配的数组
    for (int i = 0; i < n; i++) {
        dynamicArray[i] = i;
    }

    // 打印数组内容
    for (int i = 0; i < n; i++) {
        printf("%d ", dynamicArray[i]);
    }
    printf("\n");

    // 释放分配的内存
    free(dynamicArray);

    return 0;
}
```