预处理指令是在程序源代码被翻译为目标代码的过程中，生成二进制代码之前。
全部以#开头。
**考试**：宏定义、文件包含、条件编译

# 1.宏

^fda6dc

## 1.1 宏的定义`#define`
•` #define `<名字> <值>
• 注意没有结尾的分号，因为不是C的语句
• 名字必须是一个单词，值可以是各种东西
• 在C语言的编译器开始编译之前，编译预处理程序
会把程序中的名字换成值   **完全的文本替换**
## 1.2 没有值的宏（条件编译）
```c
#define _DEBUG

#ifdef _DEBUG 
// 当_DEBUG被定义时，编译器会编译这部分代码
#else
// 当_DEBUG未被定义时，编译器会编译这部分代码
#endif
```

例子
```c
#include <stdio.h>

#define _DEBUG //这里的_DEBUG已被定义

int main() {
    int a = 10;
    int b = 20;

#ifdef _DEBUG
    // 当_DEBUG被定义时，编译器会编译这部分代码
    printf("变量a的值是: %d\n", a);
    printf("变量b的值是: %d\n", b);
    // 可以在这里添加调试代码或者额外的输出信息
#else
    // 当_DEBUG未被定义时，编译器会编译这部分代码
    // 这里可以放置生产环境中的代码，比如不输出调试信息
    // 但是依然可以执行必要的逻辑
    printf("变量a和b的和是: %d\n", a + b);
#endif

    return 0;
}
```
# 1.3 写带参数的宏的注意事项
**一切都要括号
整个值都要括号
参数出现的每个地方都要有括号**
`#define RADTODEG(x) ((x) * 57.29578)`

`#define RADTODEG(x) (x * 57.29578) 错误！！！！！！`
`#define RADTODEG(x) (x) + 57.29578 错误！！！！！！`

# 2. 大程序
## 2.1 为什么要多个.c文件？
main()里的代码太长了适合分成几个函数（在一个项目中只能有一个
.c有main函数）
 一个源代码文件太长了适合分成几个文件
两个独立的源代码文件不能编译形成可执行的程序
## 2.2 编译单元
一个.c文件是一个编译单元
编译器每次编译只处理一个编译单元
**因此我们要考虑.h文件来声明**

## 2.3 头文件（文件包含，把多个.c串起来）
编译器在编译的时候只看当前的一个编译单元，它不会去看同一个项目中的其他编译单元以找出那个函数的原型
所以需要在调用函数的地方给出函数的原型，以告诉编译器那个函数究竟长什么样
### 2.3.1具体操作
* 把函数原型放到一个头文件（以.h结尾）中；
* 在需要调用这个函数的源代码文件（.c文件）中#include这个头文件
* 编译器在编译的时候就知道函数的原型
**例子**
`add.c文件 double add(int a,double b){....};函数原型`
`add.h声明 double add(int a,double b);函数声明`
`在main.c文件中 #include"add.h"`
### 2.3.2 不对外公开的函数
在函数前面加上static就使得它成为只能在所在的编译单元中被使用的函数，无法在其他.c文件中使用
在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量
```c
while{
static int m=1;
#m只能被初始化一次，并且这个函数结束后还存在，对这个文件来说是全局变量，不是局部变量
m++;
}
```

# 3. 声明
## 3.1 变量的声明
```
int i = 6;// 这是变量的定义

extern int i;// 这是变量的声明
```
声明是不产生代码的东西
定义是产生代码的东西
**只有声明可以放入头文件中**
## 3.2 标准头文件结构（防止重复声明）
直接背！！！
```c
#ifndef __LIST_HEAD__
#define __LIST_HEAD__

#include "node.h"

typedef struct _list{
Node*head;
Node*tail;
}List;
#endif
```